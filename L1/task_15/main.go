/*
var justString string
func someFunc() {
  v := createHugeString(1 << 10)
  justString = v[:100]
}

func main() {
  someFunc()
}

Использование глобальных переменных в Go является нежелательным:
   - К ним имеется лёгких доступ со всех мест, что удобно, но нужно учитывать, что
      можно изменить переменную из любого места, что может привести к неожиданностям.
   - усложняет тестирование.
   - могут легко затеняться одноимёнными локальными переменными(ф-циях, методах, циклах)
   - ещё ряд проблем, таких как возможность "гонки данных".


Строка - последовательность(массив) символов, символы в Go могут быть представленны одним или
несколькими байтами.
В данном коде justString = v[:100] "срежет" 100 первых байт и присвоит их переменной.
Проблема в том, что строка будет состоять из кириллиц, где символ занимает 2 байта, 
у нас выведется не 100 символов, а 50, к тому же, если мы обрежем нечётное количество байт(101),
то последним выведется неккоректное значение, так как мы выводим 1 байт, когда как символ(кириллица)
состоит из 2-ух байт.

Внесём корректировки в код:
*/

package main

import (
	"fmt"
	"unicode/utf8"
)

	// Функция, создающая строку.
func createHugeString(size int) string {
	var s string
	for i := 0; i < size; i++ {
			s += "я"
	}
	return s
}

func someFunc() {
	v := createHugeString(1 << 10) // Создаем большую строку.

	/* Используем utf8.RuneCountInString для определения количества символов в строке,
		так как символ может состоять из нескольких байт. 
	   Некоторые источники гласят, что лучше использовать пакет github.com/rivo/uniseg,
	   graphemeCount := uniseg.GraphemeClusterCount(v) - для более точно подсчёта.
	*/
	runeCount := utf8.RuneCountInString(v)
	

	/*
	  Преобразуем строку(v) в массив рун, затем срезаем первые 100 рун,
	  тем самым переменная будет содержать 100 символов, а не 100 байт,
	  что позволит корректно обрабатывать строки, содержащие символы
	  состоящие из нескольких байт.
	  -- justString := []rune(v)[:100]
	*/

	/*
  	  Провеяем, чтобы длина строки была не меньше количества символов, 
	   которые будет "срезать", иначе будет ошибка выхода за пределы длины строки.
	*/
	if runeCount > 100 {
		justString := []rune(v)[:100]
		fmt.Println("s: ", string(justString)) // Преобразуем срез обратно в строку.
	} else {
		// Если в строке меньше или равно 100 символов, просто выводим строку.
		fmt.Println(v)
	}
}

func main() {
	someFunc()
}

